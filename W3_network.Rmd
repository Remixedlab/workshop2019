---
title: "Network Analaysis"
author: "Meg Wu"
date: "2019/10/28"
output:
  html_document:
    theme: spacelab
    highlight: zenburn
    toc: yes
    toc_float:
      collapsed: no
    df_print: paged
editor_options:
  chunk_output_type: inline
---

<style>
    .tocify-header{color:darkred; font-size:16px;}
    .tocify-subheader{color:tomato; font-size:14px;}
    h1{color:darkred; font-size:40px;}
    h2{color:tomato; font-size:24px;}
    strong {background-color:yellow;}
</style>


# The method: Network Analysis
- Like，就是按讚
- Follow，追蹤
- Retweet，轉推（RT@）。此教學案例所定義的「互動」以轉推為主
- Reply，回推
- Mention，提到某人
- 例子: https://twitter.com/lazysundaytalk/status/1174210332014915584



# 00 Preparing data

## 0.3 Loading packages

```{r}
library(tidyverse)
library(lubridate)
library(igraph)
```



## 0.2 Loading data

```{r}
tweets_1 <- read_csv("data/china_082019_1_tweets_csv_hashed.csv")
tweets_2 <- read_csv("data/china_082019_2_tweets_csv_hashed.csv")
users_1 <- read_csv("data/china_082019_1_users_csv_hashed.csv")
users_2 <- read_csv("data/china_082019_2_users_csv_hashed.csv")
```

## 0.3 Previewing data
```{r}
tweets_1 %>% glimpse()
```


# 01 Building network data

## 1.1 Extracting RT relations

```{r}

# Filtering RT relation (366,253 out of 1,906.831)
rt_1 <- tweets_1 %>%
    select(user_screen_name, tweet_text, tweet_time) %>%
    filter(str_detect(tweet_text, "RT @"))

# Detecting retweet targets
rt_edge_1 <- rt_1 %>%
    mutate(rt_time = str_count(tweet_text, "RT @\\w+")) %>%
    filter(rt_time == 1) %>%
    mutate(to = str_extract(tweet_text, "RT @\\w+")) %>%
    mutate(to = str_sub(to, 5, nchar(to))) %>%
    select(from = user_screen_name, to, tweet_time)

rt_edge <- rt_1 %>%
    mutate(rt_time = str_count(tweet_text, "RT @\\w+")) %>%
    filter(rt_time > 1) %>%
    mutate(to = str_extract_all(tweet_text, "RT @\\w+")) %>%
    unnest(to) %>%
    mutate(to = str_sub(to, 5, nchar(to))) %>%
    select(from = user_screen_name, to, tweet_time) %>%
    bind_rows(rt_edge_1)
```

## 1.2 Extracting innert group RT relations

```{r}
rt_edge_inner <- rt_edge %>%
    filter(to %in% c(users_1$user_screen_name, users_2$user_screen_name))
```



# 02 Network data analysis

## 2.1 data frame to network

```{r}
library(igraph)

g <- rt_edge_inner %>% 
    mutate(year = year(tweet_time)) %>%
    count(from, to, year) %>%
    # filter(n > 15) %>%
    select(from, to, year, weight = n) %>%
    graph.data.frame(directed = T)
```



## 2.2 Inspecting vertices(V) and edges(E)

```{r}
E(g)$weight
E(g)$year

# V(g)
# V(g)$name
```

## 2.3 Detecting communities
```{r}

# Detecting community by information flow
V(g)$comm <- membership(infomap.community(g))
# V(g)$comm
table(V(g)$comm)
```



## 2.4 Computing vertices properties

```{r}

# centrality degree
V(g)$degree <- degree(g, mode="all")

# in-degree: interaction from out to in.
V(g)$indegree <- degree(g, mode="in")

#out-degree: Interaction from in to out
V(g)$outdegree <- degree(g, mode="out")

# closeness centrality: average of the shortest path length to other nodes
V(g)$closeness <- centralization.closeness(g)$res

# betweenness centrality: bridging degree of vertices
V(g)$betweenness <- centralization.betweenness(g)$res

```

## 2.5 Tabulating node properties
```{r}
nodes_all <- data.frame(name = V(g)$name,
                        degree = V(g)$degree,
                        indegree = V(g)$indegree,
                        outdegree = V(g)$outdegree,
                        closeness = V(g)$closeness,
                        community = V(g)$comm,
                        betweeness =V(g)$betweenness)
```



# 03 Network Visualization

## 3.1 Basic plotting

```{r}
plot(g)
plot(g, edge.arrow.size = .4, vertex.label = NA)
```


## 3.2 Plotting vertices degree distribution

```{r}
plot(degree.distribution(g, cumulative=T), pch=20, xlab="degree", ylab="cumulative frequency")
```


## 3.3 Better network plotting

```{r}
l <- layout.fruchterman.reingold(g)
# l <- layout_with_kk(g)

plot(g, 
     layout = l,
     vertex.color = rgb(1, 1, 0, 0.2),
     vertex.size  = sqrt(V(g)$degree)*3,
     vertex.frame.color= rgb(0, 0, 0, 0.5),
     vertex.label = str_sub(V(g)$name, 1, 10),
     vertex.label.cex = 0.6,
     vertex.label.color = rgb(0, 0, 0, 0.5),
     edge.curved = 0.1,
     edge.arrow.size = 0, 
     edge.width = sqrt(E(g)$weight+1),
     edge.color = E(g)$year
     )
```



# 04 Interaction analysis

## 4.1 Extracting accounts and tweets related to hk anti-extract
- After 2019-01-01

```{r}
# Keywords to detect
detects <- "港警|逃犯條例|反修例|遊行|修例|反送中|anti-extradition|hongkong|hkpolicebrutality|soshk|hongkongprotesters|HongKongPolice|hkpoliceforce|freedomHK|antiELAB|HongKongProtests|antiextraditionlaw|HongKongProtest|七一|游行|民阵|HongKong|逃犯条例|民陣|撐警|香港眾志|HongKongProterst|林鄭|警队|力撑"

hk_tweets <- tweets_1 %>%
    filter(tweet_time > as.Date("2019-01-01")) %>%
    mutate(hits = str_extract_all(tweet_text, detects)) %>%
    drop_na(hits)

# hk_users <- hk_tweets %>% 
#     count(user_screen_name, sort = T)
# 
# hk_rt <- hk_tweets %>% 
#     filter(str_detect(tweet_text, "RT @"))
# 
# hk_rt_user <- hk_rt %>%
#     count(user_screen_name, sort = T)
```


## 4.2 Comparing rt actions before and after 2019-06-05
- before: 2019-01-01 ~ 2019-06-04
- after: 2019-06-05 ~

```{r}
hk_rt_compare <- hk_tweets %>%
    mutate(anti_extract = if_else(tweet_time > as.Date("2019-06-05"), 
                                  "after", "before")) %>%
    filter(str_detect(tweet_text,"RT @")) %>%
    mutate(date = date(tweet_time)) %>%
    select(user_screen_name, tweet_text, date, anti_extract)
    
hk_rt_compare  %>% count(anti_extract)
```

## 4.3 Plotting before and after
```{r}

# Building rt edgelist of hk related tweets
hk_rt_edgelist <- hk_rt_compare %>%
    mutate(rt = str_extract_all(tweet_text, "RT @\\w+"))%>%
    unnest(rt) %>%
    mutate(to = substr(rt,5,nchar(rt))) %>%
    select(from = user_screen_name, to, anti_extract)
    

# Building graph: converting from edgelist
g_rt <- hk_rt_edgelist %>% 
    count(from, to, anti_extract) %>%
    select(from, to, anti_extract, weight = n) %>%
    graph.data.frame(directed = T)

# Examing network properties: communities
V(g_rt)$comm <- membership(infomap.community(g_rt))
table(V(g_rt)$comm)

# Examing ego-network properties
V(g_rt)$degree <- degree(g_rt, mode="all")
V(g_rt)$indegree <- degree(g_rt, mode="in")
V(g_rt)$outdegree <- degree(g_rt, mode="out")
V(g_rt)$closeness <- centralization.closeness(g_rt)$res
V(g_rt)$betweenness <- centralization.betweenness(g_rt)$res

# Saving network properties into a table
nodes_hk_rt <- data_frame(name = V(g_rt)$name,
                        degree = V(g_rt)$degree,
                        indegree = V(g_rt)$indegree,
                        outdegree = V(g_rt)$outdegree,
                        closeness = V(g_rt)$closeness,
                        community = V(g_rt)$comm,
                        betweeness =V(g_rt)$betweenness)


# Plotting network
plot(g_rt)
plot(g_rt, edge.arrow.size=.4,vertex.label=NA)
plot(degree.distribution(g_rt, cumulative=T), pch=20,xlab="degree", ylab="cumulative frequency")


# Better network plotting
l <- layout.fruchterman.reingold(g_rt)

plot(g_rt, 
     layout = l,
     vertex.color = rgb(1, 1, 0, 0.2),
     vertex.size  = sqrt(V(g_rt)$degree)*3,
     vertex.frame.color= rgb(0, 0, 0, 0.5),
     vertex.label = str_sub(V(g_rt)$name, 1, 10),
     vertex.label.cex = 0.6,
     vertex.label.color = rgb(0, 0, 0, 0.5),
     edge.curved = .1,
     edge.arrow.size = .1, 
     edge.width = sqrt(E(g_rt)$weight+1),
     edge.color = factor(E(g_rt)$anti_extract)
     )
```

