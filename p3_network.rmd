---
title: "workshop"
output: html_document
---

## 0. 前言：推特中互動的方式
#Like，就是按讚
#Follow，追蹤
#Retweet，轉推
#Reply，回推
#Mention，提到某人
#例子: https://twitter.com/lazysundaytalk/status/1174210332014915584

#此次互動使用RT@(轉推)的推文為主

##0.1 prepare files
```{r}
library(lubridate)
library(igraph)
##這裡用的是readr給我的檔案，到時候可能是用學姊的，反正先這樣
china_tweetes_filter<-read_csv("china_tweetes_filter.csv")
at_edge_list <- read_csv("at_edge_list.csv", col_types = cols(X1 = col_skip()))
tw01_tweets_language <- read_csv("tw01_tweets_language.csv")
```

##1. 整理
```{r}
hk_tweets<-china_tweetes_filter%>%
    select(user_screen_name,user_reported_location,account_language,tweet_language,tweet_text,tweet_time)
rt_users.hk<-hk_tweets%>%
    mutate(rt=ifelse(str_detect(tweet_text,"RT @"),TRUE,FALSE))%>% #分辨推特內文是否有RT @的文字
    filter(rt==TRUE)%>%  #過濾出與別人有互動的內容
    mutate(date=date(tweet_time))%>%
    select(user_screen_name,tweet_text,date)
rt_edge<-rt_users.hk%>%
    mutate(rt=str_extract_all(tweet_text, "RT @\\w+"))%>%
    unnest(rt)%>%
    mutate(target=substr(rt,5,nchar(rt)))%>%
    select(user_screen_name,target,date)%>%
    rename(screen_name=user_screen_name)
#內部的互動
rt_edge.hk<-rt_edge%>%
    left_join(at_edge_list,by=c("target"="Name"))%>%
    filter(Type=="hk")%>%
    select(screen_name,target,date)
rt_edge.not<-rt_edge%>%
    left_join(at_edge_list,by=c("target"="Name"))%>%
    # filter(Type!="hk")%>% 會出現error
    filter(is.na(Type))%>%
    select(screen_name,target,date)
```

##2. 分析
```{r}
#這裡用的是Adrian之前教過的code，我還沒問他能不能用
#畫圖也可以用gephi畫，不如說gephi比較好畫
graph_all <- graph.data.frame(rt_edge[ ,1:2], directed = T)
E(graph_all)$weight
graph_all <- graph.adjacency(get.adjacency(graph_all),weighted=TRUE)
#可以看到每個不同edge的比重
E(graph_all)$weight
# 取得vertice(頂點)
V(graph_all)
V(graph_all)$name
V(graph_all)$comm <- membership(infomap.community(graph_all))
#看看每個社群的人數
table(V(graph_all)$comm)
#centrality degree: 一個節點與其他節點的互動程度
V(graph_all)$degree <- degree(graph_all, mode="all")
#in-degree: 其他節點對此節點的互動
V(graph_all)$indegree <- degree(graph_all, mode="in")
#out-degree: 此節點向外的互動
V(graph_all)$outdegree <- degree(graph_all, mode="out")
#closeness centrality: 節點與其他節點的平均最短路徑
V(graph_all)$closeness <- centralization.closeness(graph_all)$res
#betweenness centrality: 節點作為訊息中介點的程度
V(graph_all)$betweenness <- centralization.betweenness(graph_all)$res
```

#畫圖
```{r}
plot(graph_all)
plot(graph_all, edge.arrow.size=.4,vertex.label=NA)
plot(degree.distribution(graph_all, cumulative=T), pch=20,xlab="degree", ylab="cumulative frequency")
#nodes table 可以觀察每一個節點的互動特性
nodes_all <- data.frame(name = V(graph_all)$name,
                        degree = V(graph_all)$degree,
                        indegree = V(graph_all)$indegree,
                        outdegree = V(graph_all)$outdegree,
                        closeness = V(graph_all)$closeness,
                        community = V(graph_all)$comm,
                        betweeness =V(graph_all)$betweenness)
#hk內部互動分析，照上面的作就可以，或許可以當作練習?
graph_hk <- graph.data.frame(at_edge.hk[ ,1:2], directed = T)
graph_hk <- graph.adjacency(get.adjacency(graph_hk),weighted=TRUE)
```

##5. 反送中議題的互動模式
```{r}
anti_extra_tweets<-hk_tweets%>%
    filter(tweet_time>as.Date("2019-06-05",origin = "1970-01-01"))
anti_extra_users<-anti_extra_tweets%>%
    count(user_screen_name)%>%
    arrange(-n)
#得出反送中議題後最常發文者有誰，可以用來觀察上面的node table
anti_extra_rt<-anti_extra_tweets%>%
    mutate(rt=ifelse(str_detect(tweet_text,"RT @"),TRUE,FALSE))%>%
    filter(rt==TRUE)%>% 
    mutate(date=date(tweet_time))%>%
    select(user_screen_name,tweet_text,date)
anti_extra_rt_user<-anti_extra_rt%>%
    count(user_screen_name)%>%
    arrange(-n)

#比較反送中前後互動數
compare<-hk_tweets%>%
    mutate(anti_extra=ifelse(tweet_time>as.Date("2019-06-05",origin = "1970-01-01"),"after","before"))%>%
    mutate(rt=ifelse(str_detect(tweet_text,"RT @"),TRUE,FALSE))%>%
    filter(rt==TRUE)%>% 
    mutate(date=date(tweet_time))%>%
    select(user_screen_name,tweet_text,date,anti_extra)%>%
    count(anti_extra)

#互動線段
anti_edge<-anti_extra_rt%>%
    mutate(rt=str_extract_all(tweet_text, "RT @\\w+"))%>%
    unnest(rt)%>%
    mutate(target=substr(rt,5,nchar(rt)))%>%
    select(user_screen_name,target,date)%>%
    rename(screen_name=user_screen_name)

#分析
graph_anti <- graph.data.frame(anti_edge[ ,1:2], directed = T)
graph_anti <- graph.adjacency(get.adjacency(graph_anti),weighted=TRUE)
E(graph_anti)$weight

V(graph_anti)$comm <- membership(infomap.community(graph_anti))
#看看每個社群的人數
table(V(graph_anti)$comm)
V(graph_anti)$degree <- degree(graph_anti, mode="all")
V(graph_anti)$indegree <- degree(graph_anti, mode="in")
V(graph_anti)$outdegree <- degree(graph_anti, mode="out")
V(graph_anti)$closeness <- centralization.closeness(graph_anti)$res
V(graph_anti)$betweenness <- centralization.betweenness(graph_anti)$res

#網絡圖
plot(graph_anti)
plot(graph_anti, edge.arrow.size=.4,vertex.label=NA)
plot(degree.distribution(graph_anti, cumulative=T), pch=20,xlab="degree", ylab="cumulative frequency")
#nodes table 可以觀察每一個節點的互動特性
nodes_anti <- data.frame(name = V(graph_anti)$name,
                        degree = V(graph_anti)$degree,
                        indegree = V(graph_anti)$indegree,
                        outdegree = V(graph_anti)$outdegree,
                        closeness = V(graph_anti)$closeness,
                        community = V(graph_anti)$comm,
                        betweeness =V(graph_anti)$betweenness)
```
